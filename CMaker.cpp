// For CLI stuffs
#include "CLI/App.hpp"
#include "CLI/Formatter.hpp"
#include "CLI/Config.hpp"

#include <fstream>      // to create file
#include <filesystem>   // to delete file
#include <iostream>     // for input and output
#include <cctype>       // for std::isfigit()
#include <string>       // for strings and std::stod

constexpr std::string gFilename{"CMakeLists.txt"};
constexpr std::string gDefaultCMakeMiniumRequired{"3.7...2.29"};

// Minimum for many modern practices, released in June 2014
constexpr double gLeastMinimumVersion{3.0};

// Latest available version, check https://cmake.org/download/
constexpr double gLatestAvailableVersion{3.3};

// Text for every file that was generated by CMaker
std::string addHeader()
{
    return "# This was generated by CMaker\n"
    "# With modern pratice and suggestion from https://cliutils.gitlab.io/modern-cmake/\n\n";
}

// to make sure user only put digit 
bool isNumeric(const std::string& input)
{
    for(const char& c: input)
    {
        if(!std::isdigit(c) && c != '.')
        {
            return false;
        }
    }
    return true;
}

// to make sure what user input is positive, existing version of CMake or blank for default.
bool isCMakeVersionValid(const std::string& input)
{
    if(input.empty())
    {
        return true;
    }
    else if(isNumeric(input))
    {
        double inputVersion{std::stod(input)};
        
        if(inputVersion < 0)
        {
            std::cerr << "Error: there is no negative version and never will be\n";
            return false;
        }
        else if(inputVersion < gLeastMinimumVersion)
        {
            std::cerr << "Warning: your chosen version is less than " << gLeastMinimumVersion 
            << " which is minimum for many modern practices, released in June 2014\n";
        }
        else if(inputVersion > gLatestAvailableVersion)
        {
            std::cerr << "Warning: either " << inputVersion << " does not exist yet, or my app is not updated.\n" 
            "Please check out https://cmake.org/download/ and raise and pull request if software is lagging behind\n";
        }

        return true;
    }
    else
    {
        std::cerr << "Error: wrong input, please enter correct minimum version\n";
        return false;
    }
}

std::string getCMakeVersion()
{
    std::string input{};
    do
    {
        std::cout << "Enter version: ";

        std::getline(std::cin, input);
    } 
    while(!isCMakeVersionValid(input));

    if(input.empty())
    {
        return gDefaultCMakeMiniumRequired;
    }
    else
    {
        return input;
    }
    
}

void generateCMake([[maybe_unused]]std::size_t count)
{
    std::cout << "Generating " << gFilename << '\n';

    std::ofstream cmake{gFilename};
    if(!cmake.is_open())
    {
        std::cerr << "Failed to generate " << gFilename << '\n';
        return;
    }

    cmake << addHeader();
    cmake << "cmake_minimum_required(VERSION " << getCMakeVersion() << ")\n\n";
    
    // actually saving in directory
    cmake.close();

    std::cout << gFilename << " generated successfully\n";
}

void removeCMake([[maybe_unused]]std::size_t count)
{
    std::cout << "Removing " << gFilename << '\n';

    if(std::filesystem::exists(gFilename))
    {
        std::cout << gFilename << " found\n";

        if(std::filesystem::remove(gFilename))
        {
            std::cout << "Removed\n";
        }
        else
        {
            std::cerr << "Error removing\n";
        }
    }
    else
    {
        std::cerr << gFilename << " not found\n";
    }
}

int main(int argc, char **argv) 
{
    if(argc == 1)
    {
        std::cerr << "Error: no operation specified (use -h or --help for help)\n";
        return -1;
    }

    CLI::App app{"CMaker is CLI CMake generator"};

    app.set_version_flag("-v, --version", "0.1");

    app.add_flag("-M, --make", generateCMake, "Generate " + gFilename);

    app.add_flag("-R, --remove", removeCMake, "Remove existing " + gFilename);

    CLI11_PARSE(app, argc, argv);

    return 0;
}
