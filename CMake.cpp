#include "CMake.h"
#include "Project.h"

#include "Utility.cpp"
#include "Common.h"

#include <iostream>     // for input and output
#include <fstream>      // for creating file
#include <filesystem>   // for deleting file
#include <iostream>     // for input and output
#include <string>       // for strings and std::stod

std::string CMake::addHeaderComment() const
{
    return "# This was generated by CMaker\n"
    "# With modern pratice and suggestion from https://cliutils.gitlab.io/modern-cmake/\n\n";
}

void CMake::setVersion()
{
    do
    {
        std::cout << "Enter version: ";

        std::getline(std::cin, version);
    }
    while(!isCMakeVersionValid(version));
}

void CMake::setExecutableName()
{
    do
    {
        std::cout << "Enter executable or just enter project name as executable\n";
        std::getline(std::cin, executableName);
    }
    while(Common::isContainReservedWords(executableName));
}

void CMake::setFileSource()
{
    std::string source{};
    bool isValid{false};

    while(!isValid)
    {
        std::cout << "Enter file sources or just enter for next step: ";
        std::getline(std::cin, source);

        if(source.empty())
        {
            if(fileSources.empty())
            {
                std::cerr << "Error: need at least one source\n";
            }
            else
            {
                isValid = true;
            }
        }
        else if(Utility::isFileExist(source))
        {
            fileSources.push_back(source);
        }
        else
        {
            std::cerr << "Error: " << source << " does not exist\n";
        }
    }
}

std::string CMake::addCMakePolicy() const
{
    std::string lessThanVersion{"3.12"};
    if(!version.empty())
    {
        lessThanVersion = version;
    }

    std::string policy{"if(${CMAKE_VERSION} VERSION_LESS " + lessThanVersion + ")\n"
    "\tcmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})\n"
    "endif()\n\n"};

    return policy;
}

bool CMake::isCMakeVersionValid(const std::string &input) const
{
    // user hit enter for default version
    if(input.empty())
    {
        return true;
    }
    else if(Utility::isStringNumeric(input))
    {
        double inputVersion(std::stod(input));

        if(inputVersion < 0)
        {
            std::cerr << "Error: there is no negative version and never will be\n";
            return false;
        }
        else if(inputVersion < leastMinimumVersion)
        {
            std::cerr << "Warning: your chosen version is less than " << leastMinimumVersion 
            << " which is minimum for many modern practices, released in June 2014\n";
        }
        else if(inputVersion> latestAvailableVersion)
        {
            std::cerr << "Warning: either " << inputVersion << " does not exist yet, or my app is not updated.\n" 
            "Please check out https://cmake.org/download/ and raise and pull request if software is lagging behind\n";
        }

        return true;
    }
    else
    {
        std::cerr << "Error: wrong input, please enter correct minimum version\n";
        return false;
    }
}

void CMake::writeMinimumVersion(std::ofstream &cmakeFile) const
{
    cmakeFile << "cmake_minimum_required(VERSION " << getVersion() << ")\n\n";
    cmakeFile << addCMakePolicy();
}

void CMake::settingProject(std::ofstream &cmakeFile, const Project &project) const
{
    cmakeFile << "project(" << project.getName(); 

    if(!project.getVersion().empty())
    {
        cmakeFile << " VERSION " << project.getVersion();
    }

    if(!project.getDescription().empty())
    {
        cmakeFile << " DESCRIPTION \"" << project.getDescription() << "\"";
    }
            
    cmakeFile << " LANGUAGES " << project.getLanguage() <<")\n\n";
}

void CMake::settingExecutable(std::ofstream &cmakeFile, const Project &project)
{
    setExecutableName();
    setFileSource();

    cmakeFile << "add_executable( " << getExecutableName(project) << ' ';
    
    for(const std::string &source : getFileSource())
    {
        cmakeFile << source << ' ';
    }

    cmakeFile << ")\n\n";
}

std::string CMake::getVersion() const
{
    if(version.empty())
    {
        return defaultVersion;
    }
    else
    {
        return version;
    }
}

std::string CMake::getExecutableName(const Project &project) const
{
    if(executableName.empty())
    {
        return project.getName();
    }
    else
    {
        return executableName;
    }
}

std::vector<std::string> CMake::getFileSource() const
{
    return fileSources;
}

void CMake::generateCMake([[maybe_unused]]std::size_t count)
{
    std::cout << "Generating " << gFilename << '\n';

    std::ofstream cmakeFile{gFilename};
    if(!cmakeFile.is_open())
    {
        std::cerr << "Failed to generate " << gFilename << '\n';
        return;
    }

    setVersion();

    Project project{};

    std::cout << "Setting a project\n";

    project.setName();
    project.setVersion();
    project.setDescription();
    project.setLanguage();

    cmakeFile << addHeaderComment();

    writeMinimumVersion(cmakeFile);
    settingProject(cmakeFile, project);
    settingExecutable(cmakeFile, project);

    cmakeFile.close();

    std::cout << gFilename << " generated successfully\n";
}

void CMake::removeCMake([[maybe_unused]]std::size_t count) const
{
    std::cout << "Removing " << gFilename << '\n';

    if(std::filesystem::exists(gFilename))
    {
        std::cout << gFilename << " found\n";

        if(std::filesystem::remove(gFilename))
        {
            std::cout << "Removed\n";
        }
        else
        {
            std::cerr << "Error removing\n";
        }
    }
    else
    {
        std::cerr << gFilename << " not found\n";
    }
}
