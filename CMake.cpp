#include "CMake.h"
#include "Project.h"

#include "Utility.h"
#include "Common.h"

#include <iostream>     // for input and output
#include <fstream>      // for creating file
#include <filesystem>   // for deleting file
#include <iostream>     // for input and output
#include <string>       // for strings and std::stod
#include <algorithm>    // for std::find

std::string CMake::addHeaderComment() const
{
    return "# This was generated by CMaker\n"
    "# With modern pratice and suggestion from https://cliutils.gitlab.io/modern-cmake/\n\n";
}

void CMake::setVersion()
{
    do
    {
        std::cout << "Enter version (enter to set default): ";
        std::getline(std::cin, version);
    }
    while(!isCMakeVersionValid(version));
}

void CMake::setExecutableName()
{
    constexpr bool isEmptyEnterValid{true};
    do
    {
        std::cout << "Enter executable (enter project name as executable): ";
        std::getline(std::cin, executableName);
    }
    while(!Common::isNameValid(executableName, isEmptyEnterValid));
}

void CMake::setFileSource()
{
    std::string source{};
    bool isValid{false};

    while(!isValid)
    {
        std::cout << "Enter file sources (enter for next step): ";
        std::getline(std::cin, source);

        if(source.empty())
        {
            if(fileSources.empty())
            {
                std::cerr << "Error: need at least one source\n";
            }
            else
            {
                isValid = true;
            }
        }
        else if(Utility::isFileExist(source))
        {
            fileSources.push_back(source);
        }
        else
        {
            std::cerr << "Error: " << source << " does not exist\n";
        }
    }
}

std::string CMake::addCMakePolicy() const
{
    std::string lessThanVersion{"3.12"};
    if(!version.empty())
    {
        lessThanVersion = version;
    }

    std::string policy{"if(${CMAKE_VERSION} VERSION_LESS " + lessThanVersion + ")\n"
    "\tcmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})\n"
    "endif()\n\n"};

    return policy;
}

bool CMake::isCMakeVersionValid(const std::string &input) const
{
    // user hit enter for default version
    if(input.empty())
    {
        return true;
    }
    else if(Utility::isStringNumeric(input))
    {
        const double inputVersion(std::stod(input));

        if(inputVersion < 0)
        {
            std::cerr << "Error: there is no negative version and never will be\n";
            return false;
        }
        else if(inputVersion < leastMinimumVersion)
        {
            std::cerr << "Warning: your chosen version is less than " << leastMinimumVersion 
            << " which is minimum for many modern practices, released in June 2014\n";
        }
        else if(inputVersion> latestAvailableVersion)
        {
            std::cerr << "Warning: either " << inputVersion << " does not exist yet, or my app is not updated.\n" 
            "Please check out https://cmake.org/download/ and raise and pull request if software is lagging behind\n";
        }

        return true;
    }
    else
    {
        std::cerr << "Error: wrong input, please enter correct minimum version\n";
        return false;
    }
}

void CMake::writeMinimumVersion(std::ofstream &cmakeFile) const
{
    cmakeFile << "cmake_minimum_required(VERSION " << getVersion() << ")\n\n";
    cmakeFile << addCMakePolicy();
}

void CMake::settingProject(std::ofstream &cmakeFile, const Project &project) const
{
    cmakeFile << "project(" << project.getName(); 

    if(!project.getVersion().empty())
    {
        cmakeFile << " VERSION " << project.getVersion();
    }

    if(!project.getDescription().empty())
    {
        cmakeFile << " DESCRIPTION \"" << project.getDescription() << "\"";
    }
            
    cmakeFile << " LANGUAGES " << project.getLanguage() <<")\n\n";
}

void CMake::settingExecutable(std::ofstream &cmakeFile, const Project &project)
{
    setExecutableName();
    setFileSource();

    cmakeFile << "add_executable( " << getExecutableName(project) << ' ';
    
    for(const std::string &source : getFileSource())
    {
        cmakeFile << source << ' ';
    }

    cmakeFile << ")\n\n";
}

void CMake::settingLibrary(std::ofstream &cmakeFile)
{
    LibraryInfo library{};

    while(true)
    {
        library.name = getLibraryNameFromUser();

        if(library.name.empty())
        {
            break;
        }

        library.type = getLibraryTypeFromUser();
        library.source = getLibrarySourceFromUser();

        std::cout << library.name << ' ' << library.type << ' ' << library.source;
        libraries.push_back(library);
    }

    for(const LibraryInfo &lib : libraries)
    {
        cmakeFile << "add_library(" << lib.name << ' ' << lib.type << ' ' << lib.source << ")\n";
    }

    std::cout << "\n";
}

bool CMake::isLibraryTypeValid(const std::string &type, const std::array<std::string, 3> &types)
{
    if(type.empty())
    {
        return true;
    }
    else if(Utility::isStringNumeric(type))
    {
        const int typeNumber{std::stoi(type)};

        if(typeNumber >= 0 && typeNumber < static_cast<int>(types.size()))
        {
            return true;
        }

        std::cerr << "Erro: " << typeNumber << " does not correspond to any type\n";
        
        return false;
    }
    else if(std::find(types.begin(), types.end(), type) != types.end())
    {
        return true;
    }
    else
    {
        std::cerr << "Error: does not recognise " << type << '\n';
        return false;
    }
}

std::string CMake::getLibraryNameFromUser()
{
    std::string name{};
    constexpr bool isEmptyEnterValid{true};
    do
    {
        std::cout << "Enter library name (enter for next step): ";
        std::getline(std::cin, name);
    }
    while(!Common::isNameValid(name, isEmptyEnterValid));

    return name;
}

std::string CMake::getLibraryTypeFromUser()
{
    std::string type{};
    const std::array<std::string, 3> types{"STATIC", "SHARED", "MODULE"};

    do
    {
        std::cout << "Enter library type (enter for default): ";
        std::getline(std::cin, type);
    }
    while(!isLibraryTypeValid(type, types));

    if(type.empty())
    {
        return "";
    }
    else if(Utility::isStringNumeric(type))
    {
        int typeNumber{std::stoi(type)};

        return types[static_cast<std::size_t>(typeNumber)];
    }
    else
    {
        return type;
    }
}

std::string CMake::getLibrarySourceFromUser()
{
    std::string source{};

    bool isSourceValid{false};

    while(!isSourceValid)
    {
        std::cout << "Enter the source: ";
        std::getline(std::cin, source);

        if(source.empty())
        {
            std::cerr << "Error: no source provided\n";
        }
        else if(Utility::isFileExist(source))
        {
            return source;
        }
        else
        {
            std::cerr << "Error: source does not exist\n";
        }
    }

    return source;
}

std::string CMake::getVersion() const
{
    if(version.empty())
    {
        return defaultVersion;
    }
    else
    {
        return version;
    }
}

std::string CMake::getExecutableName(const Project &project) const
{
    if(executableName.empty())
    {
        return project.getName();
    }
    else
    {
        return executableName;
    }
}

std::vector<std::string> CMake::getFileSource() const
{
    return fileSources;
}

void CMake::generateCMake([[maybe_unused]]std::size_t count)
{
    std::cout << "Generating " << gFilename << '\n';

    std::ofstream cmakeFile{gFilename};
    if(!cmakeFile.is_open())
    {
        std::cerr << "Failed to generate " << gFilename << '\n';
        return;
    }

    setVersion();

    Project project{};

    project.setName();
    project.setVersion();
    project.setDescription();
    project.setLanguage();

    cmakeFile << addHeaderComment();

    writeMinimumVersion(cmakeFile);
    settingProject(cmakeFile, project);
    settingExecutable(cmakeFile, project);

    settingLibrary(cmakeFile);

    cmakeFile.close();

    std::cout << gFilename << " generated successfully\n";
}

void CMake::removeCMake([[maybe_unused]]std::size_t count) const
{
    std::cout << "Removing " << gFilename << '\n';

    if(std::filesystem::exists(gFilename))
    {
        std::cout << gFilename << " found\n";

        if(std::filesystem::remove(gFilename))
        {
            std::cout << "Removed\n";
        }
        else
        {
            std::cerr << "Error removing\n";
        }
    }
    else
    {
        std::cerr << gFilename << " not found\n";
    }
}
